// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGResourceNode.h"

#if WITH_EDITOR
bool AFGResourceNode::IsGeyserDescButNotGeyserNode(){ return bool(); }
void AFGResourceNode::PostEditChangeProperty(  FPropertyChangedEvent& propertyChangedEvent){ }
void AFGResourceNode::CheckForErrors(){ }
#endif 
void AFGResourceNode::GetLifetimeReplicatedProps( TArray<FLifetimeProperty>& OutLifetimeProps) const{ }
AFGResourceNode::AFGResourceNode(){ }
void AFGResourceNode::PostLoad(){ Super::PostLoad(); }
void AFGResourceNode::BeginPlay(){ }
void AFGResourceNode::EndPlay( const EEndPlayReason::Type endPlayReason){ }
void AFGResourceNode::GainedSignificance_Implementation(){ }
	void AFGResourceNode::LostSignificance_Implementation(){ }
void AFGResourceNode::PreSaveGame_Implementation( int32 saveVersion, int32 gameVersion){ }
void AFGResourceNode::PostSaveGame_Implementation( int32 saveVersion, int32 gameVersion){ }
void AFGResourceNode::PreLoadGame_Implementation( int32 saveVersion, int32 gameVersion){ }
void AFGResourceNode::PostLoadGame_Implementation( int32 saveVersion, int32 gameVersion){ }
void AFGResourceNode::GatherDependencies_Implementation( TArray< UObject* >& out_dependentObjects){ }
bool AFGResourceNode::NeedTransform_Implementation(){ return bool(); }
bool AFGResourceNode::ShouldSave_Implementation() const{ return bool(); }
void AFGResourceNode::UpdateUseState_Implementation(  AFGCharacterPlayer* byCharacter, const FVector& atLocation,  UPrimitiveComponent* componentHit, FUseState& out_useState) const{ }
void AFGResourceNode::OnUse_Implementation(  AFGCharacterPlayer* byCharacter, const FUseState& state){ }
void AFGResourceNode::OnUseStop_Implementation(  AFGCharacterPlayer* byCharacter, const FUseState& state){ }
bool AFGResourceNode::IsUseable_Implementation() const{ return bool(); }
void AFGResourceNode::StartIsLookedAt_Implementation(  AFGCharacterPlayer* byCharacter, const FUseState& state){ }
FText AFGResourceNode::GetLookAtDecription_Implementation(  AFGCharacterPlayer* byCharacter, const FUseState& state) const{ return FText(); }
void AFGResourceNode::StopIsLookedAt_Implementation(  AFGCharacterPlayer* byCharacter, const FUseState& state){ }
FText AFGResourceNode::GetResourceName() const{ return FText(); }
EResourceForm AFGResourceNode::GetResourceForm() const{ return EResourceForm(); }
void AFGResourceNode::InitResource( TSubclassOf<UFGResourceDescriptor> resourceClass, EResourceAmount amount, EResourcePurity purity){ }
FText AFGResourceNode::GetResoucesLeftText() const{ return FText(); }
FText AFGResourceNode::GetResoucePurityText() const{ return FText(); }
TSubclassOf<UFGResourceDescriptor> AFGResourceNode::GetResourceClass() const{ return TSubclassOf<UFGResourceDescriptor>(); }
float AFGResourceNode::GetExtractionSpeedMultiplier() const{ return float(); }
int32 AFGResourceNode::ExtractResource( int32 amount){ return int32(); }
bool AFGResourceNode::HasAnyResources() const{ return bool(); }
void AFGResourceNode::SetIsOccupied( bool occupied){ }
void AFGResourceNode::OnRep_IsOccupied(){ }
bool AFGResourceNode::IsOccupied() const{ return bool(); }
const FInt32Interval& AFGResourceNode::GetResourceAmount( EResourceAmount amount) const{ return *(new FInt32Interval); }
int32 AFGResourceNode::GetRandomResourceAmount( EResourceAmount amount) const{ return int32(); }
void AFGResourceNode::ExtractResourceAndGiveToPlayer( AFGCharacterPlayer* toPlayer, int32 amount ){ }
int32 AFGResourceNode::GetNumResourcesPerExtract() const{ return int32(); }
void AFGResourceNode::UpdateMeshFromDescriptor( bool needRegister ){ }
void AFGResourceNode::AddRevealedOnMapBy( UObject* newObject){ }
void AFGResourceNode::RemoveRevealedOnMapBy( UObject* oldObject){ }
void AFGResourceNode::ConditionallySetupComponents( bool needRegister){ }
void AFGResourceNode::InitRadioactivity(){ }
void AFGResourceNode::UpdateRadioactivity(){ }
